"""
123456789 の部分列 3456 の考え方
1. 3456789 - 789 = 3456000
2. 3456000 / 1000 = 3456

つまり、
3456がPで割り切れるか？というのは、
-> (3456789 - 789) / 1000 が P で割り切れるか？
-> (3456789 - 789) が P で割り切れるか？(*)
-> 3456789 を P で割ったあまりと、789 を P で割ったあまりが等しいか？
と同じ意味になる。

小さい桁から1桁づつ見ていって、その桁までの数をPで割ったあまりを累積和的に持っておく
ex. 789, P=3 の場合は
700 % 3 = 2
 80 % 3 = 1
  9 % 3 = 0
- > 2 + 1 + 0 = 3 ≡ 0 (mod 3)

あまりが等しい 2 つの組み合わせの数の総和が答えになるので、
各あまりの個数を集計して、各あまりの個数についての nC2 の総和を取る

* ただし、
P が 2 or 5 の場合は、"/ 1000 (mod P)" が 0 になってしまい、
この方法が使えないため、個別に計算する

各桁の数字を見て、その数字を P で割ったあまりが 0 なら、その桁を再開桁とする数字は全部 OK になる
ex. 1230, P=2 の場合
2 % 2 = 0 なので、[2, 12] はすべて OK
0 % 2 = 0 なので、[0, 30, 230, 1230] はすべて OK

ex. 1230, P=5 の場合
0 % 5 = 0 なので、[0, 30, 230, 1230] はすべて OK
"""
from collections import defaultdict

N, P = map(int, input().split())
S = input().strip()[::-1]

if P in [2, 5]:
    ans = 0
    for r in range(N):
        if int(S[r]) % P == 0:
            ans += N - r
    print(ans)
    exit()

cum = [0] * (N + 1)
for i in range(N):
    now = int(S[i]) * pow(10, i, P)
    cum[i + 1] = (cum[i] + now) % P

cnt = defaultdict(int)
for _cum in cum:
    cnt[_cum] += 1

ans = 0
for k, v in cnt.items():
    ans += v * (v - 1) // 2

print(ans)
