"""桁DP
dp[i][j]
前からi桁使ったときの、13で割った余りがjになる数の個数

<先頭から1桁ずつ決めていく考え方>
54?21を考えてみる

54まで決まっているとき
54 ≡ 2 (mod13)
540 ≡ 54*10+0 ≡ 2*10+0 ≡ 20 ≡ 4 (mod13)
541 ≡ 54*10+1 ≡ 2*10+1 ≡ 21 ≡ 5 (mod13)
542 ≡ 54*10+2 ≡ 2*10+2 ≡ 22 ≡ 6 (mod13)
543 ≡ 54*10+3 ≡ 2*10+3 ≡ 23 ≡ 7 (mod13)
544 ≡ 54*10+4 ≡ 2*10+4 ≡ 24 ≡ 8 (mod13)
545 ≡ 54*10+5 ≡ 2*10+5 ≡ 25 ≡ 9 (mod13)
546 ≡ 54*10+6 ≡ 2*10+6 ≡ 26 ≡ 0 (mod13)
547 ≡ 54*10+7 ≡ 2*10+7 ≡ 27 ≡ 1 (mod13)
548 ≡ 54*10+8 ≡ 2*10+8 ≡ 28 ≡ 2 (mod13)
549 ≡ 54*10+9 ≡ 2*10+9 ≡ 29 ≡ 3 (mod13)
一番右の値が遷移先のj
ここに2桁目までの個数 dp[2][2] を配る
コード的には dp[2][2以外]も同じように配るが、値が0なので数字が動くわけではない

?じゃない場合(nとする): その数字だけ遷移する
---
i桁目までで余りが0 → 次の桁でnを選ぶ
i桁目までで余りが1 → 次の桁でnを選ぶ
i桁目までで余りが2 → 次の桁でnを選ぶ
...
i桁目までで余りが9 → 次の桁でnを選ぶ
---
と遷移は 1*10 回ある

==? の場合: 0〜9に遷移する
---
i桁目までで余りが0 → 次の桁で0を選ぶ
i桁目までで余りが0 → 次の桁で1を選ぶ
i桁目までで余りが0 → 次の桁で2を選ぶ
...
i桁目までで余りが0 → 次の桁で9を選ぶ
i桁目までで余りが1 → 次の桁で0を選ぶ
...
i桁目までで余りが1 → 次の桁で9を選ぶ
...
i桁目までで余りが9 → 次の桁で9を選ぶ
---
と遷移は 13*10 回ある

!=? の場合は、次の桁で個数が増えることはなく、スライドするだけ
==? の場合は、次の桁で個数が増えることがある
例えば、0 -> 3 の遷移も 6 -> 3 の遷移も加算されるから
"""
from copy import deepcopy
# 多次元配列を作成する
def make_multi_list(initial, degree):
    ans = [initial for _ in range(degree[-1])]
    for d in reversed(degree[:-1]):
        ans = [deepcopy(ans) for _ in range(d)]
    return ans

S = input().strip()
N = len(S)
MOD = 10**9+7
dp = make_multi_list(0, [N+1, 13])
dp[0][0] = 1

for i in range(N):
    c = S[i]
    ni = i + 1
    for j in range(13):
        if c == '?':
            for k in range(10):
                nj = (j * 10 + k) % 13
                dp[ni][nj] += dp[i][j]
                dp[ni][nj] %= MOD
        else:
            n = int(c)
            nj = (j * 10 + n) % 13
            dp[ni][nj] += dp[i][j]
            dp[ni][nj] %= MOD

print(dp[N][5] % MOD)

